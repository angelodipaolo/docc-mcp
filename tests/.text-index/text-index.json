{
  "documents": [
    {
      "id": "ComposableArchitecture-doc---swift-composable-architecture-ComposableArchitecture-documentation-ComposableArchitecture-Store-c3RvcmUg",
      "content": "store a store represents the runtime that powers the application. it is the object that you will pass around to views that need to interact with the application.  dynamicmemberlookup  preconcurrency  mainactor final class store state  action  overview you will typically construct a single one of these at the root of your application   main struct myapp  app   var body  some scene   windowgroup   rootview  store  store initialstate  appfeature.state      appfeature              and then use the scope state action  -90255 method to derive more focused stores that can be passed to subviews. scoping the most important operation defined on is the scope state action  -90255 method  which allows you to transform a store into one that deals with child state and actions. this is necessary for passing stores to subviews that only care about a small portion of the entire application s domain. for example  if an application has a tab view at its root with tabs for activity  search  and profile  then we can model the domain like this   reducer struct appfeature   struct state   var activity  activity.state var profile  profile.state var search  search.state   enum action   case activity activity.action  case profile profile.action  case search search.action       ...   we can construct a view for each of these domains by applying scope state action  -90255 to a store that holds onto the full app domain in order to transform it into a store for each subdomain  struct appview  view   let store  storeof appfeature  var body  some view   tabview   activityview  store  store.scope state   .activity  action   .activity    .tabitem   text  activity     searchview  store  store.scope state   .search  action   .search    .tabitem   text  search     profileview  store  store.scope state   .profile  action   .profile    .tabitem   text  profile           observableobject conformance the store conforms to observableobject but is observable via the  observedobject property wrapper. this conformance is completely inert and its sole purpose is to allow stores to be held in swiftui s  stateobject property wrapper. instead  stores should be observed through swift s observation framework  or the perception package when targeting ios  17  by applying the macro to your feature s state.",
      "metadata": {
        "archive": "ComposableArchitecture",
        "symbolId": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/Store",
        "title": "Store",
        "kind": "class",
        "url": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/Store",
        "tokens": 334
      }
    },
    {
      "id": "ComposableArchitecture-doc---swift-composable-architecture-ComposableArchitecture-documentation-ComposableArchitecture-Shared-c2hhcmVk",
      "content": "shared a property wrapper type that shares a value with other parts of the application and or external systems.  dynamicmemberlookup  propertywrapper struct shared value",
      "metadata": {
        "archive": "ComposableArchitecture",
        "symbolId": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/Shared",
        "title": "Shared",
        "kind": "struct",
        "url": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/Shared",
        "tokens": 24
      }
    },
    {
      "id": "ComposableArchitecture-doc---swift-composable-architecture-ComposableArchitecture-documentation-ComposableArchitecture-TestStore-dGVzdHN0",
      "content": "teststore a testable runtime for a reducer. preconcurrency mainactor final class teststore state action where state equatable overview this object aids in writing expressive and exhaustive tests for features built in the composable architecture. it allows you to send a sequence of actions to the store and each step of the way you must assert exactly how state changed and how effect emissions were fed back into the system. see the dedicated article for detailed information on testing. exhaustive testing by default requires you to exhaustively prove how your feature evolves from sending use actions and receiving actions from effects. there are multiple ways the test store forces you to do this for example given a simple counter reducer reducer struct counter struct state equatable var count 0 enum action case decrementbuttontapped case incrementbuttontapped var body some reducer state action reduce state action in switch action case .decrementbuttontapped state.count - 1 return .none case .incrementbuttontapped state.count 1 return .none one can assert against its behavior over time mainactor struct countertests test func basics async let store teststore given a counter state of 0 initialstate counter.state count 0 counter when the increment button is tapped await store.send .incrementbuttontapped then the count should be 1 0.count 1 note that in the trailing closure of .send .incrementbuttontapped we are given a single mutable value of the state before the action was sent and it is our job to mutate the value to match the state after the action was sent. in this case the count field changes to 1 . if the change made in the closure does not reflect reality you will get a test failure with a nicely formatted failure message letting you know exactly what went wrong await store.send .incrementbuttontapped 0.count 42 a state change does not match expectation teststorefailuretests.state - count 42 count 1 expected actual for a more complex example consider the following bare-bones search feature that uses a clock and cancel token to debounce requests reducer struct search struct state equatable var query var results string enum action case querychanged string case searchresponse result string any error dependency .apiclient var apiclient dependency .continuousclock var clock private enum cancelid case search var body some reducer state action reduce state action in switch action case let .querychanged query state.query query return .run send in try await self.clock.sleep for 0.5 await send .searchresponse result try await self.apiclient.search query .cancellable id cancelid.search cancelinflight true case let .searchresponse .success results state.results results return .none case .searchresponse .failure do error handling here. return .none it can be fully tested by overriding the apiclient and continuousclock dependencies with values that are fully controlled and deterministic create a test clock to control the timing of effects let clock testclock let store teststore initialstate search.state search withdependencies override the clock dependency with the test clock 0.continuousclock clock simulate a search response with one item 0.apiclient.search _ in composable architecture change the query await store.send .searchfieldchanged c assert that state updates accordingly 0.query c advance the clock by enough to get past the debounce await clock.advance by 0.5 assert that the expected response is received await store.receive .searchresponse.success 0.results composable architecture this test is proving that when the search query changes some search responses are delivered and state updates accordingly. if we did not assert that the searchresponse action was received we would get the following test failure the store received 1 unexpected action after this one unhandled actions 0 search.action.searchresponse this helpfully lets us know that we have no asserted on everything that happened in the feature which could be hiding a bug from us. or if we had sent another action before handling the effect s action we would have also gotten a test failure must handle 1 received action before sending an action unhandled actions 0 search.action.searchresponse all of these types of failures help you prove that you know exactly how your feature evolves as actions are sent into the system. if the library did not produce a test failure in these situations it could be hiding subtle bugs in your code. for example when the user clears the search query you probably expect that the results are cleared and no search request is executed since there is no query. this can be done like so await store.send .querychanged 0.query 0.results no need to perform store.receive since we do not expect a search effect to execute. but if in the future a bug is introduced causing a search request to be executed even when the query is empty you will get a test failure because a new effect is being created that is not being asserted on. this is the power of exhaustive testing. non-exhaustive testing while exhaustive testing can be powerful it can also be a nuisance especially when testing how many features integrate together. this is why sometimes you may want to selectively test in a non-exhaustive style. the concept of non-exhaustive test store was first introduced by in a and and then later became integrated into the core library. test stores are exhaustive by default which means you must assert on every state change and how ever effect feeds data back into the system and you must make sure that all effects complete before the test is finished. to turn off exhaustivity you can set to . when that is done the s behavior changes non-exhaustive stores can be configured to report skipped assertions by configuring . when set to true the test store will have the added behavior that any unasserted change causes a grey informational box to appear next to each assertion detailing the changes that were not asserted against. this allows you to see what information you are choosing to ignore without causing a test failure. it can be useful in tracking down bugs that happen in production but that aren t currently detected in tests. this style of testing is most useful for testing the integration of multiple features where you want to focus on just a",
      "metadata": {
        "archive": "ComposableArchitecture",
        "symbolId": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/TestStore",
        "title": "TestStore",
        "kind": "class",
        "url": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/TestStore",
        "tokens": 1000
      }
    },
    {
      "id": "ComposableArchitecture-doc---swift-composable-architecture-ComposableArchitecture-documentation-ComposableArchitecture-TestStore-cmVwb3J0",
      "content": "report skipped assertions by configuring . when set to true the test store will have the added behavior that any unasserted change causes a grey informational box to appear next to each assertion detailing the changes that were not asserted against. this allows you to see what information you are choosing to ignore without causing a test failure. it can be useful in tracking down bugs that happen in production but that aren t currently detected in tests. this style of testing is most useful for testing the integration of multiple features where you want to focus on just a certain slice of the behavior. exhaustive testing can still be important to use for leaf node features where you truly do want to assert on everything happening inside the feature. for example suppose you have a tab-based application where the 3rd tab is a login screen. the user can fill in some data on the screen then tap the submit button and then a series of events happens to log the user in. once the user is logged in the 3rd tab switches from a login screen to a profile screen the selected tab switches to the first tab which is an activity screen. when writing tests for the login feature we will want to do that in the exhaustive style so that we can prove exactly how the feature would behave in production. but suppose we wanted to write an integration test that proves after the user taps the login button that ultimately the selected tab switches to the first tab. in order to test such a complex flow we must test the integration of multiple features which means dealing with complex nested state and effects. we can emulate this flow in a test by sending actions that mimic the user logging in and then eventually assert that the selected tab switched to activity let store teststore initialstate app.state app 1 emulate user tapping on submit button. you can use case key path syntax to send actions to deeply nested features. await store.send .login.submitbuttontapped 2 assert how all state changes in the login feature 0.login .isloading true 3 login feature performs api request to login and sends response back into system. await store.receive .login.loginresponse.success 4 assert how all state changes in the login feature 0.login .isloading false 5 login feature sends a delegate action to let parent feature know it has successfully logged in. await store.receive .login.delegate.didlogin 6 assert how all of app state changes due to that action. 0.authenticatedtab .loggedin profile.state ... 7 finally assert that the selected tab switches to activity. 0.selectedtab .activity doing this with exhaustive testing is verbose and there are a few problems with this non-exhaustive testing allows us to test the high-level flow that we are concerned with that of login causing the selected tab to switch to activity without having to worry about what is happening inside the login feature. to do this we can turn off in the test store and then just assert on what we are interested in let store teststore app.state app store.exhaustivity .off await store.send .login.submitbuttontapped await store.receive .login.delegate.didlogin 0.selectedtab .activity in particular we did not assert on how the login s state changed or how the login s effects fed data back into the system. we just assert that when the submit button is tapped that eventually we get the didlogin delegate action and that causes the selected tab to flip to activity. now the login feature is free to make any change it wants to make without affecting this integration test. using for causes all un-asserted changes to pass without any notification. if you would like to see what test failures are being suppressed without actually causing a failure you can use let store teststore initialstate app.state app store.exhaustivity .off showskippedassertions true await store.send .login.submitbuttontapped await store.receive .login.delegate.didlogin 0.selectedtab .profile when this is run you will get grey informational boxes on each assertion where some change wasn t fully asserted on a state change does not match expectation app.state authenticatedtab .loggedout login.state - isloading false isloading true skipped receiving .login .loginresponse .success a state change does not match expectation app.state - authenticatedtab .loggedout authenticatedtab .loggedin profile.state expected actual the test still passes and none of these notifications are test failures. they just let you know what things you are not explicitly asserting against and can be useful to see when tracking down bugs that happen in production but that aren t currently detected in tests.",
      "metadata": {
        "archive": "ComposableArchitecture",
        "symbolId": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/TestStore",
        "title": "TestStore (part 2)",
        "kind": "class",
        "url": "doc://swift-composable-architecture.ComposableArchitecture/documentation/ComposableArchitecture/TestStore",
        "tokens": 750
      }
    }
  ],
  "timestamp": "2025-06-30T17:55:25.152Z",
  "version": "1.0.0"
}